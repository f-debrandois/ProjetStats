(co2 <- eSerre[1])
(co2 <- eSerre[3])
(co2 <- eSerre[3])
eSerre$co2[1]
(co2 = eSerre[3])
co2 <- eSerre[3]
A <- hist(co2)
co2 <- eSerre[3]
co2 <- data[,"CO2"]
co2 <- eSerre[3]
co2 <- Data[,"CO2"]
co2 <- eSerre[3]
A <- hist(co2)
co2 <- eSerre[3]
A <- hist(eSerre[3])
co2
co2 <- eSerre$co2
A <- hist(co2)
(co2 <- eSerre$co2)
A <- hist(co2)
class(co2)
class(co2)
co2 <- eSerre[3]
A <- hist(co2)
class(co2)
co2 <- eSerre$co2
A <- hist(co2)
co2
co2 <- eSerre$co2
A <- hist(co2)
attributes(A)
co2 <- eSerre$co2
A <- hist(co2)
A$breaks
help(hist)
co2 <- eSerre$co2
A <- hist(co2, breaks = "Scott")
co2 <- eSerre$co2
A <- hist(co2, breaks = "Freedman-Diaconis")
co2 <- eSerre$co2
A <- hist(co2, breaks = "max")
co2 <- eSerre$co2
A <- hist(co2, breaks = "fd")
co2 <- eSerre$co2
A <- hist(co2, breaks = "Scott")
co2 <- eSerre$co2
A <- hist(co2, breaks = "Sturges")
co2 <- eSerre$co2
A <- hist(co2, breaks = "Scott")
co2
eSerre[217,3]
eSerre[217]
eSerre[217,]
co2 <- eSerre$co2
A <- hist(co2, freq=Fbreaks = "Scott", main="Histogramme des fréquences")
co2 <- eSerre$co2
A <- hist(co2, freq=F, breaks = "Scott", main="Histogramme des fréquences")
co2 <- eSerre$co2
A_0 <- hist(co2, freq=F, breaks = "Scott", main="Histogramme des fréquences")
A_1 <- hist(co2, freq=F, breaks = "Sturges", main="Histogramme des fréquences")
co2 <- eSerre$co2
A_0 <- hist(co2, freq=F, breaks = "Scott", main="Histogramme des fréquences")
A_1 <- hist(co2, freq=F, breaks = "Sturges", main="Histogramme des fréquences")
A_2 <- hist(co2, freq=F, breaks = "fd", main="Histogramme des fréquences")
co2 <- eSerre$co2
A_0 <- hist(co2, breaks = "Scott", main="Histogramme des fréquences")
A_1 <- hist(co2, freq=F, breaks = "Sturges", main="Histogramme des fréquences")
A_2 <- hist(co2, freq=F, breaks = "fd", main="Histogramme des fréquences")
#On choisira une des trois méthodes selon sa pertinence par rapport aux autres.
#(Scott, fd, ou Sturges)
co2 <- eSerre$co2
A_0 <- hist(co2, freq=F, breaks = "Scott", main="Histogramme des fréquences")
A_1 <- hist(co2, freq=F, breaks = "Sturges", main="Histogramme des fréquences")
A_2 <- hist(co2, freq=F, breaks = "fd", main="Histogramme des fréquences")
#On choisira une des trois méthodes selon sa pertinence par rapport aux autres.
#(Scott, fd, ou Sturges)
co2 <- eSerre$co2
A_0 <- hist(co2, freq=F, breaks = "Scott", main="Histogramme des fréquences", cex.main=2)
A_1 <- hist(co2, freq=F, breaks = "Sturges", main="Histogramme des fréquences")
A_2 <- hist(co2, freq=F, breaks = "fd", main="Histogramme des fréquences")
#On choisira une des trois méthodes selon sa pertinence par rapport aux autres.
#(Scott, fd, ou Sturges)
co2 <- eSerre$co2
A_0 <- hist(co2, freq=F, breaks = "Scott", main="Histogramme des fréquences", cex.lab=2)
A_1 <- hist(co2, freq=F, breaks = "Sturges", main="Histogramme des fréquences")
A_2 <- hist(co2, freq=F, breaks = "fd", main="Histogramme des fréquences")
#On choisira une des trois méthodes selon sa pertinence par rapport aux autres.
#(Scott, fd, ou Sturges)
help(plot)
help(plot())
co2 <- eSerre$co2
A_0 <- hist(co2, freq=F, breaks = "Scott", main="Histogramme des fréquences")
A_1 <- hist(co2, freq=F, breaks = "Sturges", main="Histogramme des fréquences")
A_2 <- hist(co2, freq=F, breaks = "fd", main="Histogramme des fréquences")
#On choisira une des trois méthodes selon sa pertinence par rapport aux autres.
#(Scott, fd, ou Sturges)
plot(ecdf(co2))
co2 <- eSerre$co2
A_0 <- hist(co2, freq=F, breaks = "Scott", main="Histogramme des fréquences")
A_1 <- hist(co2, freq=F, breaks = "Sturges", main="Histogramme des fréquences")
A_2 <- hist(co2, freq=F, breaks = "fd", main="Histogramme des fréquences")
#On choisira une des trois méthodes selon sa pertinence par rapport aux autres.
#(Scott, fd, ou Sturges)
plot(ecdf(co2), main="Fonction de répartition", xlab = t, ylab=Fnx(t))
co2 <- eSerre$co2
A_0 <- hist(co2, freq=F, breaks = "Scott", main="Histogramme des fréquences")
A_1 <- hist(co2, freq=F, breaks = "Sturges", main="Histogramme des fréquences")
A_2 <- hist(co2, freq=F, breaks = "fd", main="Histogramme des fréquences")
#On choisira une des trois méthodes selon sa pertinence par rapport aux autres.
#(Scott, fd, ou Sturges)
plot(ecdf(co2), main="Fonction de répartition", xlab = "t", ylab="Fx(t)")
install(tiny_tex)
tinytex()
tinytex
library(tinytex)
tinytex::install_tinytex()
install.packages("tidyverse")
install.packages("tidyverse")
library("tidyverse")
install.packages("ellipse")
library("ellipse")
install.packages("leaps")
install.packages("MASS")
install.packages("corrplot")
install.packages("glmnet")
install.packages("coefplot")
install.packages("ggplot2")
install.packages("gridExtra")
install.packages("gfgortify")
install.packages("ggfortify")
install.packages("plotly")
install.packages("reshape2")
setwd("C:/ProjetStatsChiant/ProjetStats-master/ProjetStats-master")
acp_result
acp_data = as.data.frame(acp_result$x)
acp_result
#recherche préliminair Alexandre Demarquet 29/09 1ere séance
Data<-read.csv('Data-projetmodIA-2324.csv')
head(Data)
summary(Data)
data_quant <- Data[,3:14]
head(data_quant)
data_quant_scaled <- scale(log(data_quant))
head(data_quant_scaled)
boxplot(data_quant_scaled)
qqnorm(data_quant_scaled)
qqline(data_quant_scaled)
hist(data_quant_scaled)
table(data_quant_scaled)
cor(data_quant_scaled)
variable.names(data_quant_scaled)
str(data_quant_scaled)
data_scaled_df <- as.data.frame(data_quant_scaled)
boxplot(data_scaled_df)
pairs(data_scaled_df)
pairs(data_scaled_df[,1:2])
mat_cor <- cor(data_scaled_df)
corrplot(mat_cor,method="ellipse")
acp_result <- prcomp(data_scaled_df, scale. = TRUE)
acp_data = as.data.frame(acp_result$x)
fviz_pca_ind(acp_result, col.ind = "cos2", col.var="contrib", pointsize=2, repel="TRUE")
acp_result <- prcomp(data_scaled_df, scale. = TRUE)
acp_data = as.data.frame(acp_result$x)
fviz_pca_ind(acp_result, col.ind = "cos2", col.var="contrib", pointsize=2, repel="TRUE")
library(FactoMineR)
acp_result <- PCA(Data)
library(FactoMineR)
# Conversion des variables qualitatives en facteur
dataframe$lib_epci <- as.factor(dataframe$lib_epci)
library(FactoMineR)
# Conversion des variables qualitatives en facteur
Data$lib_epci <- as.factor(Data$lib_epci)
Data$TypeEPCI <- as.factor(Data$TypeEPCI)
Data$nomdepart <- as.factor(Data$nomdepart)
acp_result <- PCA(Data
acp_result
acp_result <- PCA(Data)
library(FactoMineR)
# Conversion des variables qualitatives en facteur
Data$lib_epci <- as.factor(Data$lib_epci)
Data$TypeEPCI <- as.factor(Data$TypeEPCI)
Data$nomdepart <- as.factor(Data$nomdepart)
acp_result <- PCA(Data)
View(Data)
type(Data$lib_epci)
class(Data$lib_epci)
class(Data$lib_epci)
#recherche préliminair Alexandre Demarquet 29/09 1ere séance
Data<-read.csv('Data-projetmodIA-2324.csv')
class(Data$lib_epci)
library(FactoMineR)
class(Data$lib_epci)
# Conversion des variables qualitatives en facteur
Data$lib_epci <- as.factor(Data$lib_epci)
Data$TypeEPCI <- as.factor(Data$TypeEPCI)
Data$nomdepart <- as.factor(Data$nomdepart)
class(Data$lib_epci)
acp_result <- PCA(Data)
View(Data)
class(Data$co_kg)
Data <- subset(Data, select = sapply(Data, is.numeric))
View(Data)
View(Data)
acp_result <- PCA(Data)
#recherche préliminair Alexandre Demarquet 29/09 1ere séance
Data<-read.csv('Data-projetmodIA-2324.csv')
#summary(Data)
#data_quant <- Data[,3:14]
#head(data_quant)
#ata_quant_scaled <- scale(log(data_quant))
#head(data_quant_scaled)
#boxplot(data_quant_scaled)
#qqnorm(data_quant_scaled)
#qqline(data_quant_scaled)
#hist(data_quant_scaled)
#table(data_quant_scaled)
#cor(data_quant_scaled)
#variable.names(data_quant_scaled)
#str(data_quant_scaled)
#data_scaled_df <- as.data.frame(data_quant_scaled)
#boxplot(data_scaled_df)
#pairs(data_scaled_df)
#pairs(data_scaled_df[,1:2])
#mat_cor <- cor(data_scaled_df)
#corrplot(mat_cor,method="ellipse")
#corrplot(mat_cor,method="shade")
#hist(data_scaled_df$nox_kg)
# La transformation logarithmique peut faciliter l'interprétation des valeurs,
#en particulier lorsque les données présentent des variations importantes
#et que la standardisation ne suffit pas à rendre la distribution plus normale.
#dans rapport expliquier l'interet de la transformation en log des données et montré un exemple classique
#puis mettre un chunk de R pas compile pour montrer l'interet sur les autres variabables
# Suppression des variables non numeric
library(FactoMineR)
acp_result <- PCA(Data)
View(Data)
var_qualitatives = c(Data[1:3])
var_qualitatives
View(Data)
View(Data)
var_qualitatives = c(Data[4:14])
var_qualitatives
View(Data)
Data_clean <- Data[4:14]
Data_clean
View(Data_clean)
View(Data)
library(FactoMineR)
Data_clean <- Data[4:14]
Data_clean
acp_result <- PCA(Data_clean)
acp_result
plot(acp_result)
library(FactoMineR)
Data <- Data[4:14]
Data_clean <- scale(log(Data))
acp_result <- PCA(Data_clean)
plot(acp_result)
fviz_pca_ind(resultats_acp, col.ind = "cos2",
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE # Évite le chevauchement de texte
)
View(Data)
View(Data)
View(Data_clean)
Data<-read.csv('Data-projetmodIA-2324.csv')
View(Data)
# Créer un vecteur de couleurs en fonction de l'année
couleurs <- as.factor(Data_clean$code_epci)
#recherche préliminair Alexandre Demarquet 29/09 1ere séance
Data<-read.csv('Data-projetmodIA-2324.csv')
#summary(Data)
#data_quant <- Data[,3:14]
#head(data_quant)
#ata_quant_scaled <- scale(log(data_quant))
#head(data_quant_scaled)
#boxplot(data_quant_scaled)
#qqnorm(data_quant_scaled)
#qqline(data_quant_scaled)
#hist(data_quant_scaled)
#table(data_quant_scaled)
#cor(data_quant_scaled)
#variable.names(data_quant_scaled)
#str(data_quant_scaled)
#data_scaled_df <- as.data.frame(data_quant_scaled)
#boxplot(data_scaled_df)
#pairs(data_scaled_df)
#pairs(data_scaled_df[,1:2])
#mat_cor <- cor(data_scaled_df)
#corrplot(mat_cor,method="ellipse")
#corrplot(mat_cor,method="shade")
#hist(data_scaled_df$nox_kg)
# La transformation logarithmique peut faciliter l'interprétation des valeurs,
#en particulier lorsque les données présentent des variations importantes
#et que la standardisation ne suffit pas à rendre la distribution plus normale.
#dans rapport expliquier l'interet de la transformation en log des données et montré un exemple classique
#puis mettre un chunk de R pas compile pour montrer l'interet sur les autres variabables
# Suppression des variables non numeric
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
acp_result <- PCA(Data_clean, graph=FALSE)
# Créer un vecteur de couleurs en fonction de l'année
couleurs <- as.factor(Data$code_epci)
# Réaliser le graphique en coloriant par année
plot(resultat_acp, choix = "ind", habillage = couleurs, title = "ACP - Individus par année")
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
acp_result <- PCA(Data_clean, graph=FALSE)
# Créer un vecteur de couleurs en fonction de l'année
couleurs <- as.factor(Data$code_epci)
# Réaliser le graphique en coloriant par année
plot(acp_result, choix = "ind", habillage = couleurs, title = "ACP - Individus par type d'ECPI")
View(Data)
View(Data)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
color <- Data_clean$TypeEPCI; color[color="CC"] <- "black"; color[color="CA"] <- "red";
class(Data_clean)
View(Data_clean)
Data_clean <- as.data.frame(Data_clean)
View(Data_clean)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
color <- Data_clean$TypeEPCI; color[color="CC"] <- "black"; color[color="CA"] <- "red";
color[color="CU"] <- "green"; color[color="Metropole"] <- "blue";
acp_result <- PCA(Data_clean, graph=FALSE, habillage=color)
View(Data_clean)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
color <- Data_clean$TypeEPCI; color[color="CC"] <- "black"; color[color="CA"] <- "red";
color[color="CU"] <- "green"; color[color="Metropole"] <- "blue";
acp_result <- PCA(Data_clean, graph=FALSE)
plot.PCA(acp_result, col=color)
plot.PCA(acp_result, habillage =color)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
color <- Data_clean$TypeEPCI; color[color="CC"] <- "black"; color[color="CA"] <- "red";
color[color="CU"] <- "green"; color[color="Metropole"] <- "blue";
acp_result <- PCA(Data_clean, graph=FALSE)
plot.PCA(acp_result, habillage =color)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
# ... (votre code pour préparer les données)
color <- Data_clean$TypeEPCI
color <- factor(color, levels = c("CC", "CA", "CU", "Metropole"))
# Assigner les couleurs
palette_couleurs <- c("black", "red", "green", "blue")
color <- palette_couleurs[color]
acp_result <- PCA(Data_clean, graph = FALSE)
plot.PCA(acp_result, habillage = color)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
# ... (votre code pour préparer les données)
color <- Data_clean$TypeEPCI
color <- factor(color, levels = c("CC", "CA", "CU", "Metropole"))
# Assigner les couleurs
palette_couleurs <- c("black", "red", "green", "blue")
color <- palette_couleurs[as.integer(color)]
acp_result <- PCA(Data_clean, graph = FALSE)
plot.PCA(acp_result, habillage = color)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
color <- Data_clean$TypeEPCI; color[color="CC"] <- "black"; color[color="CA"] <- "red";
color[color="CU"] <- "green"; color[color="Metropole"] <- "blue";
acp_result <- PCA(Data_clean, graph=FALSE)
plot.PCA(acp_result, habillage =color)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
Data$TypeEPCI <- copy(Data$lib_epci)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
Data$TypeEPCI <- copy(Data$lib_epci)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
acp_result <- PCA(Data_clean, graph=FALSE, color=col_type)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
acp_result <- PCA(Data_clean, graph=FALSE, habillage=col_type)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
acp_result <- PCA(Data_clean, graph=FALSE)
plot(acp_result, habillage=col_type)
library(FactoMineR)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
acp_result <- PCA(Data_clean, graph=FALSE)
plot(acp_result, color=col_type)
library(ggfortify)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
Data_clean=cbind(col_type,Data_clean)
autoplot(Data_clean, graph=TRUE, color='col_type')
library(ggfortify)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
Data_clean=cbind(col_type,Data_clean)
pca_res=prcomp(Data_clean)
library(ggfortify)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
Data_clean=cbind(col_type,Data_clean)
pca_res=prcomp(Data_clean)
pca_res=prcomp(Data_clean)
pca_res<-prcomp(Data_clean)
library(ggfortify)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
pca_res<-prcomp(Data_clean)
Data_clean=cbind(col_type,Data_clean)
autoplot(pca_res,data=Data_clean, graph=TRUE, color='col_type')
# Calcul de la matrice de covariance
covariance_matrix <- cov(Data_Clean)
# Calcul de la matrice de covariance
covariance_matrix <- cov(Data_clean)
install.packages("Matrix")
library(ggfortify)
library(Matrix)
# Calcul de la matrice de covariance
covariance_matrix <- cov(Data_clean)
str(Data_clean)
Data<-read.csv('Data-projetmodIA-2324.csv')
library(ggfortify)
library(Matrix)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
# Calcul de la matrice de covariance
covariance_matrix <- cov(Data_clean)
# Calcul de la racine inverse de la matrice de covariance
inverse_cov_sqrt <- solve(sqrtm(covariance_matrix))
library(ggfortify)
library(Matrix)
Data_quali <- Data[4:14]
Data_clean <- scale(log(Data_quali))
Data_clean <- as.data.frame(Data_clean)
col_type = Data[,2]
for (i in 1:length(col_type)){
col_type[i] = substr(col_type[i], 1, 2)
}
pca_res<-prcomp(Data_clean)
Data_clean=cbind(col_type,Data_clean)
autoplot(pca_res,data=Data_clean, graph=TRUE, color='col_type')
