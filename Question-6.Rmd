---
title: "Question 6"
output:
  pdf_document: default
  html_document: default
date: "2023-12-01"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r,echo=FALSE,include=FALSE}
library(reticulate)
library(ggplot2)
library(corrplot)
library(FactoMineR)
library(factoextra)
library(gridExtra)

library(ellipse)
library(leaps)
library(glmnet)
library(coefplot)

library(ggfortify)
library(plotly)   
library(reshape2)

data = read.csv("Data-projetmodIA-2324.csv")
```
```{r,echo=FALSE}
dlog=data[4:15]
data_quant=data[4:14]
data_quant=scale(log(data_quant))
dlog[1:11]=data_quant
dlog=data.frame(dlog,annee_inv=data$annee_inv)
```

```{r,echo=TRUE}
anov2= lm(ges_teqco2 ~TypeEPCI * annee_inv, data=dlog)
```
## Modèle linéaire

  Nous avons vu précédemment comment classer les données, de façon supervisée ou non. Nous allons maintenant voir comment nous pouvons expliquer les données. Nous allons effectuer différents modèles linéaires, afin d'évaluer les variables expliquant : le gaz à effet de serre, et l'

```{r}
anov_sans_int=lm(ges_teqco2 ~TypeEPCI + annee_inv, data=dlog)
anova(anov_sans_int,anov2)
```

```{r}
anov_annee=lm(ges_teqco2 ~annee_inv, data=dlog)
anov_type=lm(ges_teqco2 ~TypeEPCI, data=dlog)

anova(anov_annee,anov_sans_int)
anova(anov_type,anov_sans_int)
```
```{r}
anova(lm(ges_teqco2 ~1, data=dlog),anov_type)

```
```{r}
anova(anov_type,anov2)

```


On garde le modèle anov_type:

```{r}
summary(anov_type)

```
On peut pas annuler 1 des paramètres, on ne peut donc pas regrouper des modalités entre elles, et on garde donc ce modèle. On essaye de voir sa capacité de prédiction:
```{r}
dlog=data[4:15]
data_quant=data[4:14]
data_quant=scale(log(data_quant))
dlog[1:11]=data_quant
dlog=data.frame(dlog,annee_inv=data$annee_inv)
taille_train=round(0.7*nrow(dlog))
d_train=dlog[1:taille_train,]
d_test=dlog[taille_train:nrow(dlog),]

mod_anov=lm(ges_teqco2 ~TypeEPCI, data=d_train)
pred=predict(mod_anov,d_test)
resultat=data.frame(vrai_ges=d_test$ges_teqco2,prediction=pred,ecart=abs(d_test$ges_teqco2-pred),erreur_pourcentage=abs(d_test$ges_teqco2-pred)/abs(d_test$ges_teqco2))
summary(resultat)
taux_err=sum(resultat$ecart)/nrow(resultat)
print(taux_err)

p_err=sum(resultat$erreur_pourcentage)/nrow(resultat)
print(p_err)

#absc=seq(-4, 4, length.out = nrow(d_test))

#g1= ggplot(resultat,aes(x=vrai_ges,y=prediction))+geom_point()
#g2= ggplot(resultat,aes(x=absc,y=vrai_ges))+geom_point()
#g3= ggplot(resultat,aes(x=absc,y=prediction))+geom_point()

#grid.arrange(g1,g2,g3,ncol=2)
```
  Nous vérifions le modèle que nous avons obtenu en faisant un peu de prédiction. Pour cela, on crée le modèle sur 70% des données, et on essaye de prédire la valeur du gaz à effet de serre sur les 30% restants. Les résultats obtenus montrent un écart moyen entre la réalité et la prédiction, soit un écart moyen de 13,15%.



```{r}
dlog=data[4:15]
data_quant=data[4:14]
data_quant=scale(log(data_quant))
dlog[1:11]=data_quant
dlog=data.frame(dlog,annee_inv=data$annee_inv)

nv_type=dlog$TypeEPCI; nv_type[nv_type=="CU"]="Metr_CU";  nv_type[nv_type=="Metropole"]="Metr_CU"

dlog2=dlog
dlog2$TypeEPCI=nv_type

anov22= lm(ges_teqco2 ~TypeEPCI * annee_inv, data=dlog2)
summary(anov2)
```
```{r}
anov_sans_int2=lm(ges_teqco2 ~TypeEPCI + annee_inv, data=dlog2)
anova(anov_sans_int2,anov22)
```

```{r}
anov_annee2=lm(ges_teqco2 ~annee_inv, data=dlog2)
anov_type2=lm(ges_teqco2 ~TypeEPCI, data=dlog2)

anova(anov_annee2,anov_sans_int2)
anova(anov_type2,anov_sans_int2)
```
```{r}
anova(anov_type2,anov22)

```
```{r}
dlog=data[4:15]
data_quant=data[4:14]
data_quant=scale(log(data_quant))
dlog[1:11]=data_quant
dlog=data.frame(dlog,annee_inv=data$annee_inv)

nv_type=dlog$TypeEPCI; nv_type[nv_type=="CU"]="Metr_CU";  nv_type[nv_type=="Metropole"]="Metr_CU"

dlog2=dlog
dlog2$TypeEPCI=nv_type

taille_train=round(0.7*nrow(dlog2))
d_train=dlog2[1:taille_train,]
d_test=dlog2[taille_train:nrow(dlog2),]

mod_anov=lm(ges_teqco2 ~TypeEPCI, data=d_train)
pred=predict(mod_anov,d_test)
resultat=data.frame(vrai_ges=d_test$ges_teqco2,prediction=pred,ecart=abs(d_test$ges_teqco2-pred),erreur_pourcentage=abs(d_test$ges_teqco2-pred)/abs(d_test$ges_teqco2))
summary(resultat)

taux_err=sum(resultat$ecart)/nrow(resultat)
p_err=sum(resultat$erreur_pourcentage)/nrow(resultat)
print(taux_err)
print(p_err)


```
Ancova:
```{r}
dlog=data[4:15]
data_quant=data[4:14]
data_quant=scale(log(data_quant))
dlog[1:11]=data_quant
dlog=data.frame(dlog,annee_inv=data$annee_inv)
bon_indice=c(7,9,11,12,13)
dlog=dlog[bon_indice]

summary(dlog)

ancov= lm(ch4_t ~ .^2, data=dlog)
summary(ancov)
```

```{r}
ancov_sans_interact=lm(ch4_t ~ ., data=dlog)
anova(ancov_sans_interact,ancov)
```

```{r}
library("MASS")
modselect_aic=stepAIC(ancov,trace=T,direction="backward")
```
```{r}
modselect_bic=stepAIC(ancov,trace=T,direction="backward",k=log(nrow(dlog)))
```
```{r}
anova(modselect_bic,ancov)

model_bic_precedent=lm(ch4_t ~ nh3_kg + n2o_t + TypeEPCI + annee_inv + nh3_kg:n2o_t + 
    nh3_kg:TypeEPCI + n2o_t:TypeEPCI + n2o_t:annee_inv,data=dlog)
anova(model_bic_precedent,ancov)
```
```{r}
nv_type=dlog$TypeEPCI; nv_type[nv_type=="CU"]="Metr_CU";  nv_type[nv_type=="Metropole"]="Metr_CU"

dlog2=dlog
dlog2$TypeEPCI=nv_type

ancov_modif_type= lm(ch4_t ~ .^2, data=dlog2)
summary(ancov_modif_type)

```
```{r}
ancov_modif_type_sans_interact=lm(ch4_t ~ ., data=dlog2)
anova(ancov_modif_type_sans_interact,ancov_modif_type)
```
```{r}
modselect_bic_v2=stepAIC(ancov_modif_type,trace=T,direction="backward",k=log(nrow(dlog2)))
```

```{r}
anova(modselect_bic_v2,ancov_modif_type)

bic_prec=lm(ch4_t ~ nh3_kg + n2o_t + TypeEPCI + annee_inv + nh3_kg:n2o_t + 
    nh3_kg:TypeEPCI + nh3_kg:annee_inv + n2o_t:TypeEPCI + n2o_t:annee_inv, data=dlog2)

anova(bic_prec,ancov_modif_type)


```
Alors, pour l'ancova on remarque que l'on ne peut pas trop simplifier, pas du tout avec les variables classiques, et on peut enlever qqles interactions quand on regroupe certaines modalités de TypeEPCI



###MLG:

Nous avons vu différents modèles linéaires pour essayer d'expliquer les variables, nous allons maintenant voir un modèle linéaire généralisé. Nous allons expliquer une variable binaire, à savoir le dépassement d’émission de méthane de 1000 t par an, par des variables qualitatives et quantitatives. Nous allons donc faire une régression logistique. Considérons le modèle suivant: 

$$
\begin{align*}
  & dep_i \sim \mathcal{B(\pi_i)}, \text{avec } dep_i \perp\!\!\!\perp \forall i\\
  & \pi_i = \theta_0+\theta_1 nh3kg_i + \theta_2 n2ot_i+ \sum_{j \in T} \beta_j \mathbb{1}\{TypeEPCI_i = j\} + \sum_{a=2015}^{2019} \alpha_a \mathbb{1}\{annee_i = a\}
\end{align*}
$$
  
  

```{r,echo=FALSE}
dlog=data[4:15]
data_quant=data[4:14]
data_quant=scale(log(data_quant))
dlog[1:11]=data_quant
dlog=data.frame(dlog,annee_inv=data$annee_inv)
bon_indice=c(7,9,11,12,13)
dlog=dlog[bon_indice]
dlog$ch4_t=data$ch4_t>1000

#summary(dlog)

mlg_init=glm(ch4_t~.^2,data=dlog,family=binomial(link="logit"))
summary(mlg_init)


```
```{r,echo=FALSE,include=FALSE}
mlg_sans_interact=glm(ch4_t~.,data=dlog,family=binomial(link="logit"))
anova(mlg_sans_interact,mlg_init,test="Chisq")
```
```{r, echo=FALSE,include=FALSE}
library("MASS")
mlg_bic=stepAIC(mlg_init,trace=F,direction="backward",k=log(nrow(dlog)))
summary(mlg_bic)
```
```{r,echo=FALSE,include=FALSE}
anova(mlg_bic,mlg_init,test="Chisq")
```

  Nous avons essayé de simplifier ce modèle, en enlevant les intéractions, mais nous avons rejeté l'hypothèse car nous obtenions un p-valeur trop petite. Nous avons également essayé de mettre en place une méthode backward pour trouver un sous-modèle acceptable, mais encore une fois nous avons obtenu un p-valeur trop petite, et nous avons rejeté le sous modèle. Ce modèle ne semble donc pas pouvoir se simplifier, et nous allons tester son efficaité en faisant de la prédiction. 
    Nous prenons 70% de l'échantillon pour faire le modèle, et nous testons sur les 30% restants. 



```{r,echo=FALSE}
library(caret)

taille_train=round(0.7*nrow(dlog))
d_train=dlog[1:taille_train,]
d_test=dlog[taille_train:nrow(dlog),]

pred=predict(mlg_init,d_test)
resultat=data.frame(vrai_res=d_test$ch4_t,prediction=pred)
resultat$prediction=resultat$prediction >0.5
resultat$erreur= abs(resultat$prediction-resultat$vrai_res)
taux_erreur=sum(resultat$erreur)/nrow(resultat)
conf_mat=confusionMatrix(as.factor(resultat$prediction),as.factor(resultat$vrai_res))
```

```{r fig1,echo=FALSE,eval=TRUE,fig.cap="\\label{fig:fig1}Prédiction sur le taux de méthane",fig.height=3}
heatmap_data <- as.data.frame(conf_mat$table)

ggplot(heatmap_data, aes(x = Reference, y = Prediction, fill = Freq)) +
  geom_tile(color = "white") +
  geom_text(aes(label = sprintf("%d", Freq)), vjust = 1) +
  scale_fill_gradient(low = "white", high = "steelblue") +
  labs(title = "Matrice de Confusion",
       x = "Vraie Valeur",
       y = "Prédiction")


```
Nous obtenons la figure \ref{fig:fig1}. Ce résultat a un taux de précision de :
```{r,echo=FALSE,results='asis'}
cat(as.numeric(conf_mat$overall[1]))
```
. C'est très correct, car avec la LDA nous obtenions un taux de 0.92 à peu près. Ainsi, en ne gardant que certaines variables, nous obtenons un score plutôt proche. On en déduit que l’ammoniac, le protoxyde d’azote, le type d’EPCI et l’année explique bien le dépassement d’émission de méthane de 1000 t par an.